---
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import ToastProvider from '../components/ToastProvider.tsx';
import '../styles/global.css';
import SearchPage from '../components/SearchPage';

// Rest of imports and props remain the same

export interface Props {
  // Basic SEO
  name: string;
  title: string;
  path: string;
  description?: string;
  canonical?: string;
  keywords?: string[];
  ogImage?: string;
  twitterImage?: string;

  // Layout
  showHeader?: boolean;

  // Content metadata
  datePublished?: string;
  dateModified?: string;
  softwareVersion?: string;
  features?: string[];
  author?: string;
  license?: string;
  category?: string;

  // Image/Media
  imgWidth?: number;
  imgHeight?: number;
  thumbnailUrl?: string;
  encodingFormat?: string;

  // Hierarchical structure
  partOf?: string;
  partOfUrl?: string;

  // Schema type override
  pageType?: string;

  // Collection/List specific
  totalItems?: number;
  itemsPerPage?: number;
  currentPage?: number;

  // Tool specific
  toolType?: string;
  toolCategory?: string;

  // Icon specific
  iconName?: string;
  iconCategory?: string;
  iconTags?: string[];

  // Emoji specific
  emojiCode?: string;
  emojiCategory?: string;

  // Command/Cheatsheet specific
  commandName?: string;
  platform?: string;
  commandCategory?: string;

  // MCP Repository specific
  githubUrl?: string;
}

const {
  // Basic SEO
  name,
  title,
  description,
  canonical,
  keywords = [],
  ogImage = 'https://hexmos.com/freedevtools/site-banner.png',
  twitterImage = 'https://hexmos.com/freedevtools/site-banner.png',

  // Layout
  showHeader = true,

  // Content metadata
  datePublished,
  dateModified,
  softwareVersion = '1.0.0',
  features = [],
  author = 'Free DevTools by Hexmos',
  license = 'MIT',
  category,

  // Image/Media
  imgWidth = 1136,
  imgHeight = 768,
  thumbnailUrl,
  encodingFormat = 'text/html',

  // Hierarchical structure
  partOf = 'Free DevTools',
  partOfUrl = 'https://hexmos.com/freedevtools/',

  // Schema type override
  pageType: customPageType,

  // Collection/List specific
  totalItems,
  itemsPerPage,
  currentPage = 1,

  // Tool specific
  toolType,
  toolCategory,

  // Icon specific
  iconName,
  iconCategory,
  iconTags = [],

  // Emoji specific
  emojiCode,
  emojiCategory,

  // Command/Cheatsheet specific
  commandName,
  platform,
  commandCategory,

  // MCP Repository specific
  githubUrl,
} = Astro.props;

const currentUrl = canonical || Astro.url.href;
const keywordsString = keywords.length > 0 ? keywords.join(', ') : '';

// Determine page type based on path and props
function determinePageType(path: string, props: any): string {
  if (props.pageType) return props.pageType;

  // SVG Icon pages
  if (path.includes('/svg_icons/')) {
    if (path.match(/\/svg_icons\/[^\/]+\/[^\/]+$/)) {
      return 'ImageObject'; // Individual icon page
    } else if (path.match(/\/svg_icons\/[^\/]+$/)) {
      return 'CollectionPage'; // Category page
    } else {
      return 'CollectionPage'; // Main SVG icons page
    }
  }

  // Tool pages
  if (path.match(/\/t\/[^\/]+$/) || path.match(/\/t\/[^\/]+\/[^\/]+$/)) {
    return 'SoftwareApplication';
  }

  // Cheatsheet pages
  if (path.includes('/c/')) {
    if (path.match(/\/c\/[^\/]+\/[^\/]+$/)) {
      return 'TechArticle'; // Individual cheatsheet
    } else if (path.match(/\/c\/[^\/]+$/)) {
      return 'CollectionPage'; // Category page
    } else {
      return 'CollectionPage'; // Main cheatsheets page
    }
  }

  // TLDR pages
  if (path.includes('/tldr/')) {
    if (path.match(/\/tldr\/[^\/]+\/[^\/]+$/)) {
      return 'TechArticle'; // Individual command page
    } else if (path.match(/\/tldr\/[^\/]+$/)) {
      return 'CollectionPage'; // Platform page
    } else {
      return 'CollectionPage'; // Main TLDR page
    }
  }

  // MCP pages
  if (path.includes('/mcp/')) {
    if (path.match(/\/mcp\/[^\/]+\/[^\/]+$/)) {
      return 'SoftwareApplication'; // Individual MCP repository page
    } else if (path.match(/\/mcp\/[^\/]+$/)) {
      return 'CollectionPage'; // MCP category page
    } else {
      return 'CollectionPage'; // Main MCP page
    }
  }

  // Emoji pages
  if (path.includes('/emojis/')) {
    if (path.match(/\/emojis\/[^\/]+$/)) {
      return 'CollectionPage'; // Category page
    } else {
      return 'CollectionPage'; // Main emojis page
    }
  }

  // Default
  return 'WebPage';
}

// Generate base schema properties
function getBaseSchema(props: any) {
  const currentDate = new Date().toISOString();

  return {
    '@context': 'https://schema.org',
    url: props.canonical || currentUrl,
    inLanguage: 'en',
    datePublished: props.datePublished || currentDate,
    dateModified: props.dateModified || currentDate,
    author: {
      '@type': 'Organization',
      name: props.author || 'Free DevTools by Hexmos',
      url: 'https://hexmos.com/freedevtools/',
    },
    publisher: {
      '@type': 'Organization',
      name: 'Free DevTools by Hexmos',
      url: 'https://hexmos.com/freedevtools/',
    },
    isPartOf: {
      '@type': 'Collection',
      name: props.partOf || 'Free DevTools',
      url: props.partOfUrl || 'https://hexmos.com/freedevtools/',
    },
    license:
      props.license === 'MIT'
        ? 'https://opensource.org/licenses/MIT'
        : props.license || 'https://opensource.org/licenses/MIT',
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': props.canonical || currentUrl,
    },
  };
}

// Generate specific schema based on page type
function generatePageSpecificSchema(pageType: string, props: any) {
  const baseSchema = getBaseSchema(props);

  switch (pageType) {
    case 'ImageObject': // Individual SVG icon
      return {
        ...baseSchema,
        '@type': 'ImageObject',
        name: props.iconName || props.name,
        alternateName: props.keywords || [],
        description: props.description,
        contentUrl: props.thumbnailUrl || props.ogImage,
        thumbnailUrl: props.thumbnailUrl || props.ogImage,
        image: props.thumbnailUrl || props.ogImage,
        encodingFormat: props.encodingFormat || 'image/svg+xml',
        width: props.imgWidth,
        height: props.imgHeight,
        keywords: [...(props.keywords || []), ...(props.iconTags || [])].join(
          ', '
        ),
        about: {
          '@type': 'Thing',
          name: props.iconCategory || props.category,
        },
        offers: {
          '@type': 'Offer',
          price: '0',
          priceCurrency: 'USD',
          availability: 'https://schema.org/InStock',
        },
        license:
          props.license === 'MIT'
            ? 'https://opensource.org/licenses/MIT'
            : props.license || 'https://opensource.org/licenses/MIT',
        creator: {
          '@type': 'Organization',
          name: props.author || 'Free DevTools by Hexmos',
          url: 'https://hexmos.com/freedevtools/',
        },
        copyrightHolder: {
          '@type': 'Organization',
          name: props.author || 'Free DevTools by Hexmos',
        },
        copyrightYear: new Date().getFullYear(),
        isAccessibleForFree: true,
        usageInfo: {
          '@type': 'CreativeWork',
          text: 'Free to use under MIT license. No attribution required but appreciated.',
        },
      };

    case 'SoftwareApplication': // Tool page or MCP repository
      const isMcpRepository = props.path?.includes('/mcp/');

      if (isMcpRepository) {
        return {
          ...baseSchema,
          '@type': 'SoftwareApplication',
          name: props.name,
          alternateName: props.keywords || [],
          description: props.description,
          applicationCategory: 'DeveloperTool',
          operatingSystem: 'Any',
          browserRequirements: 'Requires Node.js, MCP Client',
          softwareVersion: props.softwareVersion,
          featureList: props.features || [],
          keywords: props.keywords?.join(', ') || '',
          screenshot: props.ogImage,
          programmingLanguage: 'TypeScript',
          runtimePlatform: 'Node.js',
          softwareRequirements:
            'Model Context Protocol (MCP) compatible client',
          category: 'Model Context Protocol Server',
          offers: {
            '@type': 'Offer',
            price: '0',
            priceCurrency: 'USD',
            availability: 'https://schema.org/InStock',
          },
          codeRepository: {
            '@type': 'SoftwareSourceCode',
            url: props.githubUrl || props.url,
            programmingLanguage: 'TypeScript',
            license:
              props.license === 'MIT'
                ? 'https://opensource.org/licenses/MIT'
                : props.license || 'https://opensource.org/licenses/MIT',
          },
        };
      } else {
        return {
          ...baseSchema,
          '@type': 'SoftwareApplication',
          name: props.name,
          alternateName: props.keywords || [],
          description: props.description,
          applicationCategory: 'DeveloperTool',
          operatingSystem: 'Any',
          browserRequirements: 'Requires JavaScript. Requires HTML5.',
          softwareVersion: props.softwareVersion,
          featureList: props.features || [],
          keywords: props.keywords?.join(', ') || '',
          screenshot: props.ogImage,
          offers: {
            '@type': 'Offer',
            price: '0',
            priceCurrency: 'USD',
            availability: 'https://schema.org/InStock',
          },
        };
      }

    case 'TechArticle': // Command/Cheatsheet page
      return {
        ...baseSchema,
        '@type': 'TechArticle',
        headline: props.name,
        alternateName: props.keywords || [],
        description: props.description,
        articleBody: props.description,
        keywords: props.keywords?.join(', ') || '',
        about: {
          '@type': 'Thing',
          name: props.commandName || props.name,
        },
        mentions: props.platform
          ? {
              '@type': 'Thing',
              name: props.platform,
            }
          : undefined,
        articleSection: props.commandCategory || props.category,
      };

    case 'CollectionPage': // Category/List pages
      const collectionSchema: any = {
        ...baseSchema,
        '@type': 'CollectionPage',
        name: props.name,
        alternateName: props.keywords || [],
        description: props.description,
        keywords: props.keywords?.join(', ') || '',
        mainEntity: {
          '@type': 'ItemList',
          numberOfItems: props.totalItems || 0,
          itemListElement: [], // This would be populated with actual items
        },
      };

      // Add pagination info if available
      if (props.totalItems && props.itemsPerPage) {
        collectionSchema.mainEntity.numberOfItems = props.totalItems;
        collectionSchema.mainEntity.numberOfPages = Math.ceil(
          props.totalItems / props.itemsPerPage
        );
        collectionSchema.mainEntity.currentPage = props.currentPage;
      }

      return collectionSchema;

    default: // WebPage
      return {
        ...baseSchema,
        '@type': 'WebPage',
        name: props.name,
        alternateName: props.keywords || [],
        description: props.description,
        keywords: props.keywords?.join(', ') || '',
      };
  }
}

// Generate the final schema
const detectedPageType = determinePageType(Astro.props.path, Astro.props);
const schema = generatePageSpecificSchema(detectedPageType, Astro.props);

// Debug: Print the final schema
// console.log('🔍 JSON-LD Schema for:', Astro.props.path);
// console.log('📄 Page Type:', detectedPageType);
// console.log('📋 Generated Schema:', JSON.stringify(schema, null, 2));
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Theme initialization script -->
    <script is:inline>
      (function () {
        const theme = localStorage.getItem('theme') || 'dark';
        const prefersDark = window.matchMedia(
          '(prefers-color-scheme: dark)'
        ).matches;
        if (theme === 'dark' || (!theme && prefersDark)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      })();
    </script>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Basic SEO Meta Tags -->
    <title>{title}</title>
    {description && <meta name="description" content={description} />}
    {keywordsString && <meta name="keywords" content={keywordsString} />}
    {canonical && <link rel="canonical" href={canonical} />}

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    {description && <meta property="og:description" content={description} />}
    <meta property="og:url" content={currentUrl} />
    <meta property="og:image" content={thumbnailUrl || ogImage} />
    <meta property="og:site_name" content="Free DevTools by Hexmos" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    {description && <meta name="twitter:description" content={description} />}
    <meta name="twitter:image" content={thumbnailUrl || twitterImage} />

    <!-- JSON-LD Structured Data -->
    {
      schema && (
        <script type="application/ld+json" set:html={JSON.stringify(schema)} />
      )
    }

    <!-- Additional SEO Meta Tags -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="Free DevTools by Hexmos" />
    <meta name="publisher" content="Hexmos" />
    <meta name="generator" content="Astro" />

    <!-- Image-specific meta tags for better SEO -->
    {
      thumbnailUrl && (
        <>
          <meta name="image" content={thumbnailUrl} />
          <meta property="og:image:width" content={imgWidth.toString()} />
          <meta property="og:image:height" content={imgHeight.toString()} />
          <meta property="og:image:type" content={encodingFormat} />
          <meta property="og:image:alt" content={name} />
          <meta name="twitter:image:alt" content={name} />
        </>
      )
    }

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/freedevtools/t/favicon.webp" />

    <!-- Resource hints for better performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
    <link rel="preconnect" href="https://api.github.com" crossorigin />
    <link rel="preconnect" href="https://github.com" crossorigin />
    <link rel="dns-prefetch" href="//hexmos.com" />
    <link rel="dns-prefetch" href="//www.googletagmanager.com" />
    <link rel="dns-prefetch" href="//www.google-analytics.com" />

    <!-- Fonts - Optimized loading -->
    <!-- Preload critical fonts for faster loading -->
    <link
      rel="preload"
      href="/freedevtools/fonts/Cal_Sans/CalSans-Regular.ttf"
      as="font"
      type="font/ttf"
      crossorigin="anonymous"
    />

    <!-- Load fonts CSS with proper optimization -->
    <link rel="stylesheet" href="/freedevtools/fonts/fonts.css" media="all" />

    <!-- Theme initialization script -->
    <script>
      (function () {
        const theme = localStorage.getItem('theme') || 'dark';
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      })();
    </script>

    <!-- Load local fonts CSS. -->
    <link rel="stylesheet" href="/freedevtools/fonts/fonts.css" />

    <!-- Optimized GTM loading -->
    <script>
      (function () {
        const GA_MEASUREMENT_ID = 'G-WXSDF484XZ';
        const GTM_ID = 'GTM-KH6DG8PP';

        // minimal dataLayer init
        window.dataLayer = window.dataLayer || [];
        window.dataLayer.push({
          'gtm.start': new Date().getTime(),
          event: 'gtm.js',
        });

        function loadGTM() {
          if (window.__gtmLoaded) return;
          window.__gtmLoaded = true;

          const s = document.createElement('script');
          s.async = true;
          s.src = `https://www.googletagmanager.com/gtm.js?id=${GTM_ID}`;
          document.head.appendChild(s);
        }

        // trigger load on first interaction or after idle timeout
        const trigger = () => loadGTM();
        ['scroll', 'pointerdown', 'keydown', 'mousemove'].forEach((evt) =>
          window.addEventListener(evt, trigger, { once: true, passive: true })
        );

        if ('requestIdleCallback' in window)
          requestIdleCallback(loadGTM, { timeout: 5000 });
        else setTimeout(loadGTM, 5000);
      })();
    </script>

    <!-- Add global search state -->
    <script>
      // Add type definition for window
      interface SearchState {
        query: string;
        setQuery: (query: string) => void;
        getQuery: () => string;
      }

      // Extend Window interface
      interface Window {
        searchState?: SearchState;
      }

      // Initialize global search state
      window.searchState = {
        query: '',
        setQuery: function (query) {
          this.query = query;
          // Dispatch an event when query changes
          window.dispatchEvent(
            new CustomEvent('searchQueryChanged', {
              detail: { query },
            })
          );
        },
        getQuery: function () {
          return this.query;
        },
      };
    </script>
  </head>
  <body
    class="m-0 p-0 font-sans bg-slate-50 text-slate-800 leading-relaxed dark:bg-slate-900 dark:text-slate-200 min-h-screen flex flex-col"
  >
    <!-- Skip Links for Accessibility -->
    <a
      href="#main-content"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-blue-600 text-white px-4 py-2 rounded-md z-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      Skip to main content
    </a>
    <a
      href="#navigation"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-32 bg-blue-600 text-white px-4 py-2 rounded-md z-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      Skip to navigation
    </a>
    <a
      href="#search"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-64 bg-blue-600 text-white px-4 py-2 rounded-md z-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      Skip to search
    </a>

    <div class="flex flex-1 flex-col">
      {showHeader && <Header />}

      <main
        class="flex-1 overflow-auto bg-background"
        class:list={[showHeader ? 'pt-16 md:pt-16' : 'pt-0 lg:pt-0']}
        id="main-content"
        role="main"
        aria-labelledby="main-content-heading"
      >
        <ToastProvider client:load>
          <div id="main-page">
            <div
              id="search-container"
              style="display: none;"
              class="max-w-6xl mx-auto px-2 md:px-6"
            >
              <SearchPage client:load />
            </div>
            <div id="slot-container">
              <slot />
            </div>
          </div>

          <script>
            // Function to toggle visibility based on search query
            function toggleSearchView() {
              const searchContainer =
                document.getElementById('search-container');
              const slotContainer = document.getElementById('slot-container');

              // Handle the case where elements aren't found
              if (!searchContainer || !slotContainer) return;

              // Safely access window.searchState
              const searchQuery = window.searchState?.getQuery?.() || '';

              if (searchQuery.trim()) {
                searchContainer.style.display = 'block';
                slotContainer.style.display = 'none';
              } else {
                searchContainer.style.display = 'none';
                slotContainer.style.display = 'block';
              }
            }

            // Initialize and set up listener
            document.addEventListener('DOMContentLoaded', function () {
              // Initial toggle based on search state
              toggleSearchView();

              // Listen for search query changes
              window.addEventListener('searchQueryChanged', toggleSearchView);
            });
          </script>
        </ToastProvider>
      </main>

      <!-- Footer -->
      <Footer />
    </div>
  </body>
</html>
